{
  "version": 3,
  "sources": ["../lib/base.js", "../lib/dcovmatmtk.js", "../lib/ndarray.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nvar isRowMajor = require( '@stdlib/ndarray-base-assert-is-row-major' );\nvar dcovarmtk = require( '@stdlib/stats-strided-dcovarmtk' ).ndarray;\nvar dvarmtk = require( '@stdlib/stats-strided-dvarmtk' ).ndarray;\nvar dlacpy = require( '@stdlib/lapack-base-dlacpy' ).ndarray;\n\n\n// MAIN //\n\n/**\n* Computes the covariance matrix for an `M` by `N` double-precision floating-point matrix `A` and assigns the results to a matrix `B` when provided known means and using a one-pass textbook algorithm.\n*\n* ## Notes\n*\n* -   When `orient(A) = 'columns'`,\n*\n*     -   each column in `A` represents a variable and each row in `A` represents an observation.\n*     -   `B` should be an `N` by `N` matrix.\n*     -   the list of known means should be an `N` element vector.\n*\n* -   When `orient(A) = 'rows'`,\n*\n*     -   each row in `A` represents a variable and each column in `A` represents an observation.\n*     -   `B` should be an `M` by `M` matrix.\n*     -   the list of known means should be an `M` element vector.\n*\n* @private\n* @param {string} orient - specifies whether variables are stored along columns or along rows\n* @param {string} uplo - specifies whether to overwrite the upper or lower triangular part of matrix `B`\n* @param {NonNegativeInteger} M - number of rows in the matrix `A`\n* @param {NonNegativeInteger} N - number of columns in the matrix `A`\n* @param {number} correction - degrees of freedom adjustment\n* @param {Float64Array} means - vector of known means\n* @param {integer} strideM - stride length for `means`\n* @param {NonNegativeInteger} offsetM - starting index for `means`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* // Define a 2x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'rows', 'full', 2, 3, 1, means, 1, 0, A, 3, 1, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* // Define a 3x2 matrix in which variables are stored along columns in row-major order:\n* var A = new Float64Array([\n*     1.0, 2.0,\n*     -2.0, -2.0,\n*     2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'columns', 'full', 3, 2, 1, means, 1, 0, A, 2, 1, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* // Define a 2x3 matrix in which variables are stored along rows in column-major order:\n* var A = new Float64Array( [ 1.0, 2.0, -2.0, -2.0, 2.0, 1.0 ] );\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'rows', 'full', 2, 3, 1, means, 1, 0, A, 1, 2, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* // Define a 3x2 matrix in which variables are stored along columns in column-major order:\n* var A = new Float64Array( [ 1.0, -2.0, 2.0, 2.0, -2.0, 1.0 ] );\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'columns', 'full', 3, 2, 1, means, 1, 0, A, 1, 3, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* // Define a 4x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0,\n*     2.0, -2.0, 1.0,\n*     1.0, -2.0, 2.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0, 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 4x4 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'rows', 'full', 4, 3, 1, means, 1, 0, A, 3, 1, 0, B, 4, 1, 0 );\n* // returns <Float64Array>[ ~4.33, ~3.83, ~3.83, ~4.33, ~3.83, ~4.33, ~4.33, ~3.83, ~3.83, ~4.33, ~4.33, ~3.83, ~4.33, ~3.83, ~3.83, ~4.33 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* // Define a 3x4 matrix in which variables are stored along columns in column-major order:\n* var A = new Float64Array( [ 1.0, -2.0, 2.0, 2.0, -2.0, 1.0, 2.0, -2.0, 1.0, 1.0, -2.0, 2.0 ] );\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0, 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 4x4 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'columns', 'full', 3, 4, 1, means, 1, 0, A, 1, 3, 0, B, 4, 1, 0 );\n* // returns <Float64Array>[ ~4.33, ~3.83, ~3.83, ~4.33, ~3.83, ~4.33, ~4.33, ~3.83, ~3.83, ~4.33, ~4.33, ~3.83, ~4.33, ~3.83, ~3.83, ~4.33 ]\n*\n* var bool = ( B === out );\n* // returns true\n*/\nfunction dcovmatmtk( orient, uplo, M, N, correction, means, strideM, offsetM, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar nsamples;\n\tvar isrmb;\n\tvar full;\n\tvar nobs;\n\tvar sa1;\n\tvar sa0;\n\tvar sb1;\n\tvar sb0;\n\tvar sb;\n\tvar oa;\n\tvar om;\n\tvar ia;\n\tvar ib;\n\tvar im;\n\tvar i0;\n\tvar i1;\n\n\t// Determine the memory layouts of `B`:\n\tisrmb = isRowMajor( [ strideB1, strideB2 ] );\n\n\t// Determine the outer and inner loop strides when writing to the upper or lower triangular part of `B`...\n\tif ( uplo === 'upper') {\n\t\t// Writing to the upper triangular part is cache optimal for a row-major `B`, but not for a column-major `B`...\n\t\tsb0 = strideB2;\n\t\tsb1 = strideB1;\n\t} else if ( uplo === 'lower' ) {\n\t\t// Writing to the lower triangular part is cache optimal for a column-major `B`, but not for a row-major `B`...\n\t\tsb0 = strideB1;\n\t\tsb1 = strideB2;\n\t} else {\n\t\t// When computing the full covariance matrix, write covariances in a manner which is cache optimal for the layout of `B`...\n\t\tfull = true;\n\t\tif ( isrmb ) {\n\t\t\t// For row-major matrices, the last dimension has the fastest changing index...\n\t\t\tsb0 = strideB2;\n\t\t\tsb1 = strideB1;\n\t\t} else {\n\t\t\t// For column-major matrices, the first dimension has the fastest changing index...\n\t\t\tsb0 = strideB1;\n\t\t\tsb1 = strideB2;\n\t\t}\n\t}\n\t// Resolve loop variables...\n\tif ( orient === 'rows' ) {\n\t\tsa0 = strideA2;\n\t\tsa1 = strideA1;\n\t\tnsamples = M;\n\t\tnobs = N;\n\t} else { // orient === 'columns'\n\t\tsa0 = strideA1;\n\t\tsa1 = strideA2;\n\t\tnsamples = N;\n\t\tnobs = M;\n\t}\n\t// Compute the variances and set them along the diagonal...\n\tsb = strideB1 + strideB2; // stride for elements along diagonal\n\tia = offsetA;\n\tib = offsetB;\n\tim = offsetM;\n\tfor ( i0 = 0; i0 < nsamples; i0++ ) {\n\t\tB[ ib ] = dvarmtk( nobs, correction, means[ im ], A, sa0, ia );\n\t\tia += sa1;\n\t\tib += sb;\n\t\tim += strideM;\n\t}\n\t// Compute pairwise covariances...\n\toa = offsetA;\n\tom = offsetM;\n\tfor ( i1 = 0; i1 < nsamples-1; i1++ ) {\n\t\tib = offsetB + ( sb1*i1 ) + ( sb0*i1 );\n\t\tia = oa;\n\t\tim = om;\n\t\tfor ( i0 = i1+1; i0 < nsamples; i0++ ) {\n\t\t\tim += strideM;\n\t\t\tia += sa1;\n\t\t\tib += sb0;\n\t\t\tB[ ib ] = dcovarmtk( nobs, correction, means[ om ], A, sa0, oa, means[ im ], A, sa0, ia );\n\t\t}\n\t\toa += sa1;\n\t\tom += strideM;\n\t}\n\t// Copy the covariances to the other triangular part if the full covariance matrix is desired...\n\tif ( full ) {\n\t\tif ( isrmb ) {\n\t\t\t// Copy the upper triangular part to the lower triangular part:\n\t\t\tdlacpy( 'upper', nsamples, nsamples, B, sb1, sb0, offsetB, B, sb0, sb1, offsetB );\n\t\t} else {\n\t\t\t// Copy the lower triangular part to the upper triangular part:\n\t\t\tdlacpy( 'lower', nsamples, nsamples, B, sb0, sb1, offsetB, B, sb1, sb0, offsetB );\n\t\t}\n\t}\n\treturn B;\n}\n\n\n// EXPORTS //\n\nmodule.exports = dcovmatmtk;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nvar isOrientation = require( '@stdlib/blas-base-assert-is-matrix-orientation' );\nvar isLayout = require( '@stdlib/blas-base-assert-is-layout' );\nvar isColumnMajor = require( '@stdlib/ndarray-base-assert-is-column-major-string' );\nvar stride2offset = require( '@stdlib/strided-base-stride2offset' );\nvar format = require( '@stdlib/string-format' );\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Computes the covariance matrix for an `M` by `N` double-precision floating-point matrix `A` and assigns the results to a matrix `B` when provided known means and using a one-pass textbook algorithm.\n*\n* ## Notes\n*\n* -   When `orient(A) = 'columns'`,\n*\n*     -   each column in `A` represents a variable and each row in `A` represents an observation.\n*     -   `B` should be an `N` by `N` matrix.\n*     -   the list of known means should be an `N` element vector.\n*\n* -   When `orient(A) = 'rows'`,\n*\n*     -   each row in `A` represents a variable and each column in `A` represents an observation.\n*     -   `B` should be an `M` by `M` matrix.\n*     -   the list of known means should be an `M` element vector.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} orient - specifies whether variables are stored along columns or along rows\n* @param {string} uplo - specifies whether to overwrite the upper or lower triangular part of matrix `B`\n* @param {NonNegativeInteger} M - number of rows in the matrix `A`\n* @param {NonNegativeInteger} N - number of columns in the matrix `A`\n* @param {number} correction - degrees of freedom adjustment\n* @param {Float64Array} means - vector of known means\n* @param {integer} strideM - stride length of `means`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float64Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {TypeError} second argument must be a valid orientation\n* @throws {RangeError} fourth argument must be a nonnegative integer\n* @throws {RangeError} fifth argument must be a nonnegative integer\n* @returns {Float64Array} `B`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* // Define a 2x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'row-major', 'rows', 'full', 2, 3, 1, means, 1, A, 3, B, 2 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*/\nfunction dcovmatmtk( order, orient, uplo, M, N, correction, means, strideM, A, LDA, B, LDB ) {\n\tvar nsamples;\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( !isOrientation( orient ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a valid orientation. Value: `%s`.', orient ) );\n\t}\n\tif ( M < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be a nonnegative integer. Value: `%d`.', M ) );\n\t}\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\tif ( orient === 'rows' ) {\n\t\tnsamples = M;\n\t} else { // orient === 'columns'\n\t\tnsamples = N;\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( orient, uplo, M, N, correction, means, strideM, stride2offset( nsamples, strideM ), A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nmodule.exports = dcovmatmtk;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nvar isOrientation = require( '@stdlib/blas-base-assert-is-matrix-orientation' );\nvar format = require( '@stdlib/string-format' );\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Computes the covariance matrix for an `M` by `N` double-precision floating-point matrix `A` and assigns the results to a matrix `B` when provided known means and using a one-pass textbook algorithm and alternative indexing semantics.\n*\n* ## Notes\n*\n* -   When `orient(A) = 'columns'`,\n*\n*     -   each column in `A` represents a variable and each row in `A` represents an observation.\n*     -   `B` should be an `N` by `N` matrix.\n*     -   the list of known means should be an `N` element vector.\n*\n* -   When `orient(A) = 'rows'`,\n*\n*     -   each row in `A` represents a variable and each column in `A` represents an observation.\n*     -   `B` should be an `M` by `M` matrix.\n*     -   the list of known means should be an `M` element vector.\n*\n* @param {string} orient - specifies whether variables are stored along columns or along rows\n* @param {string} uplo - specifies whether to overwrite the upper or lower triangular part of matrix `B`\n* @param {NonNegativeInteger} M - number of rows in the matrix `A`\n* @param {NonNegativeInteger} N - number of columns in the matrix `A`\n* @param {number} correction - degrees of freedom adjustment\n* @param {Float64Array} means - vector of known means\n* @param {integer} strideM - stride length for `means`\n* @param {NonNegativeInteger} offsetM - starting index of `means`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @throws {TypeError} first argument must be a valid orientation\n* @throws {RangeError} third argument must be a nonnegative integer\n* @throws {RangeError} fourth argument must be a nonnegative integer\n* @returns {Float64Array} `B`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* // Define a 2x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'rows', 'full', 2, 3, 1, means, 1, 0, A, 3, 1, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*/\nfunction dcovmatmtk( orient, uplo, M, N, correction, means, strideM, offsetM, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tif ( !isOrientation( orient ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid orientation. Value: `%s`.', orient ) );\n\t}\n\tif ( M < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Third argument must be a nonnegative integer. Value: `%d`.', M ) );\n\t}\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( orient, uplo, M, N, correction, means, strideM, offsetM, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n}\n\n\n// EXPORTS //\n\nmodule.exports = dcovmatmtk;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar dcovmatmtk = require( './dcovmatmtk.js' );\nvar ndarray = require( './ndarray.js' );\n\n\n// MAIN //\n\nsetReadOnly( dcovmatmtk, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nmodule.exports = dcovmatmtk;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute the covariance matrix for an `M` by `N` double-precision floating-point matrix `A` and assign the results to a matrix `B` when provided known means and using a one-pass textbook algorithm.\n*\n* @module @stdlib/stats-strided-dcovmatmtk\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var dcovmatmtk = require( '@stdlib/stats-strided-dcovmatmtk' );\n*\n* // Define a 2x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'row-major', 'rows', 'full', 2, 3, 1, means, 1, A, 3, B, 2 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var dcovmatmtk = require( '@stdlib/stats-strided-dcovmatmtk' );\n*\n* // Define a 2x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk.ndarray( 'rows', 'full', 2, 3, 1, means, 1, 0, A, 3, 1, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nvar tryRequire = require( '@stdlib/utils-try-require' );\nvar isError = require( '@stdlib/assert-is-error' );\nvar main = require( './main.js' );\n\n\n// MAIN //\n\nvar dcovmatmtk;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdcovmatmtk = main;\n} else {\n\tdcovmatmtk = tmp;\n}\n\n\n// EXPORTS //\n\nmodule.exports = dcovmatmtk;\n\n// exports: { \"ndarray\": \"dcovmatmtk.ndarray\" }\n"],
  "mappings": "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",
  "names": ["require_base", "__commonJSMin", "exports", "module", "isRowMajor", "dcovarmtk", "dvarmtk", "dlacpy", "dcovmatmtk", "orient", "uplo", "M", "N", "correction", "means", "strideM", "offsetM", "A", "strideA1", "strideA2", "offsetA", "B", "strideB1", "strideB2", "offsetB", "nsamples", "isrmb", "full", "nobs", "sa1", "sa0", "sb1", "sb0", "sb", "oa", "om", "ia", "ib", "im", "i0", "i1", "require_dcovmatmtk", "__commonJSMin", "exports", "module", "isOrientation", "isLayout", "isColumnMajor", "stride2offset", "format", "base", "dcovmatmtk", "order", "orient", "uplo", "M", "N", "correction", "means", "strideM", "A", "LDA", "B", "LDB", "nsamples", "sa1", "sa2", "sb1", "sb2", "require_ndarray", "__commonJSMin", "exports", "module", "isOrientation", "format", "base", "dcovmatmtk", "orient", "uplo", "M", "N", "correction", "means", "strideM", "offsetM", "A", "strideA1", "strideA2", "offsetA", "B", "strideB1", "strideB2", "offsetB", "require_main", "__commonJSMin", "exports", "module", "setReadOnly", "dcovmatmtk", "ndarray", "join", "tryRequire", "isError", "main", "dcovmatmtk", "tmp"]
}
