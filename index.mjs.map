{"version":3,"file":"index.mjs","sources":["../lib/base.js","../lib/dcovmatmtk.js","../lib/ndarray.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major';\nimport { ndarray as dcovarmtk } from '@stdlib/stats-strided-dcovarmtk';\nimport { ndarray as dvarmtk } from '@stdlib/stats-strided-dvarmtk';\nimport { ndarray as dlacpy } from '@stdlib/lapack-base-dlacpy';\n\n\n// MAIN //\n\n/**\n* Computes the covariance matrix for an `M` by `N` double-precision floating-point matrix `A` and assigns the results to a matrix `B` when provided known means and using a one-pass textbook algorithm.\n*\n* ## Notes\n*\n* -   When `orient(A) = 'columns'`,\n*\n*     -   each column in `A` represents a variable and each row in `A` represents an observation.\n*     -   `B` should be an `N` by `N` matrix.\n*     -   the list of known means should be an `N` element vector.\n*\n* -   When `orient(A) = 'rows'`,\n*\n*     -   each row in `A` represents a variable and each column in `A` represents an observation.\n*     -   `B` should be an `M` by `M` matrix.\n*     -   the list of known means should be an `M` element vector.\n*\n* @private\n* @param {string} orient - specifies whether variables are stored along columns or along rows\n* @param {string} uplo - specifies whether to overwrite the upper or lower triangular part of matrix `B`\n* @param {NonNegativeInteger} M - number of rows in the matrix `A`\n* @param {NonNegativeInteger} N - number of columns in the matrix `A`\n* @param {number} correction - degrees of freedom adjustment\n* @param {Float64Array} means - vector of known means\n* @param {integer} strideM - stride length for `means`\n* @param {NonNegativeInteger} offsetM - starting index for `means`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Define a 2x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'rows', 'full', 2, 3, 1, means, 1, 0, A, 3, 1, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Define a 3x2 matrix in which variables are stored along columns in row-major order:\n* var A = new Float64Array([\n*     1.0, 2.0,\n*     -2.0, -2.0,\n*     2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'columns', 'full', 3, 2, 1, means, 1, 0, A, 2, 1, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Define a 2x3 matrix in which variables are stored along rows in column-major order:\n* var A = new Float64Array( [ 1.0, 2.0, -2.0, -2.0, 2.0, 1.0 ] );\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'rows', 'full', 2, 3, 1, means, 1, 0, A, 1, 2, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Define a 3x2 matrix in which variables are stored along columns in column-major order:\n* var A = new Float64Array( [ 1.0, -2.0, 2.0, 2.0, -2.0, 1.0 ] );\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'columns', 'full', 3, 2, 1, means, 1, 0, A, 1, 3, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Define a 4x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0,\n*     2.0, -2.0, 1.0,\n*     1.0, -2.0, 2.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0, 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 4x4 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'rows', 'full', 4, 3, 1, means, 1, 0, A, 3, 1, 0, B, 4, 1, 0 );\n* // returns <Float64Array>[ ~4.33, ~3.83, ~3.83, ~4.33, ~3.83, ~4.33, ~4.33, ~3.83, ~3.83, ~4.33, ~4.33, ~3.83, ~4.33, ~3.83, ~3.83, ~4.33 ]\n*\n* var bool = ( B === out );\n* // returns true\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Define a 3x4 matrix in which variables are stored along columns in column-major order:\n* var A = new Float64Array( [ 1.0, -2.0, 2.0, 2.0, -2.0, 1.0, 2.0, -2.0, 1.0, 1.0, -2.0, 2.0 ] );\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0, 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 4x4 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'columns', 'full', 3, 4, 1, means, 1, 0, A, 1, 3, 0, B, 4, 1, 0 );\n* // returns <Float64Array>[ ~4.33, ~3.83, ~3.83, ~4.33, ~3.83, ~4.33, ~4.33, ~3.83, ~3.83, ~4.33, ~4.33, ~3.83, ~4.33, ~3.83, ~3.83, ~4.33 ]\n*\n* var bool = ( B === out );\n* // returns true\n*/\nfunction dcovmatmtk( orient, uplo, M, N, correction, means, strideM, offsetM, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tvar nsamples;\n\tvar isrmb;\n\tvar full;\n\tvar nobs;\n\tvar sa1;\n\tvar sa0;\n\tvar sb1;\n\tvar sb0;\n\tvar sb;\n\tvar oa;\n\tvar om;\n\tvar ia;\n\tvar ib;\n\tvar im;\n\tvar i0;\n\tvar i1;\n\n\t// Determine the memory layouts of `B`:\n\tisrmb = isRowMajor( [ strideB1, strideB2 ] );\n\n\t// Determine the outer and inner loop strides when writing to the upper or lower triangular part of `B`...\n\tif ( uplo === 'upper') {\n\t\t// Writing to the upper triangular part is cache optimal for a row-major `B`, but not for a column-major `B`...\n\t\tsb0 = strideB2;\n\t\tsb1 = strideB1;\n\t} else if ( uplo === 'lower' ) {\n\t\t// Writing to the lower triangular part is cache optimal for a column-major `B`, but not for a row-major `B`...\n\t\tsb0 = strideB1;\n\t\tsb1 = strideB2;\n\t} else {\n\t\t// When computing the full covariance matrix, write covariances in a manner which is cache optimal for the layout of `B`...\n\t\tfull = true;\n\t\tif ( isrmb ) {\n\t\t\t// For row-major matrices, the last dimension has the fastest changing index...\n\t\t\tsb0 = strideB2;\n\t\t\tsb1 = strideB1;\n\t\t} else {\n\t\t\t// For column-major matrices, the first dimension has the fastest changing index...\n\t\t\tsb0 = strideB1;\n\t\t\tsb1 = strideB2;\n\t\t}\n\t}\n\t// Resolve loop variables...\n\tif ( orient === 'rows' ) {\n\t\tsa0 = strideA2;\n\t\tsa1 = strideA1;\n\t\tnsamples = M;\n\t\tnobs = N;\n\t} else { // orient === 'columns'\n\t\tsa0 = strideA1;\n\t\tsa1 = strideA2;\n\t\tnsamples = N;\n\t\tnobs = M;\n\t}\n\t// Compute the variances and set them along the diagonal...\n\tsb = strideB1 + strideB2; // stride for elements along diagonal\n\tia = offsetA;\n\tib = offsetB;\n\tim = offsetM;\n\tfor ( i0 = 0; i0 < nsamples; i0++ ) {\n\t\tB[ ib ] = dvarmtk( nobs, correction, means[ im ], A, sa0, ia );\n\t\tia += sa1;\n\t\tib += sb;\n\t\tim += strideM;\n\t}\n\t// Compute pairwise covariances...\n\toa = offsetA;\n\tom = offsetM;\n\tfor ( i1 = 0; i1 < nsamples-1; i1++ ) {\n\t\tib = offsetB + ( sb1*i1 ) + ( sb0*i1 );\n\t\tia = oa;\n\t\tim = om;\n\t\tfor ( i0 = i1+1; i0 < nsamples; i0++ ) {\n\t\t\tim += strideM;\n\t\t\tia += sa1;\n\t\t\tib += sb0;\n\t\t\tB[ ib ] = dcovarmtk( nobs, correction, means[ om ], A, sa0, oa, means[ im ], A, sa0, ia );\n\t\t}\n\t\toa += sa1;\n\t\tom += strideM;\n\t}\n\t// Copy the covariances to the other triangular part if the full covariance matrix is desired...\n\tif ( full ) {\n\t\tif ( isrmb ) {\n\t\t\t// Copy the upper triangular part to the lower triangular part:\n\t\t\tdlacpy( 'upper', nsamples, nsamples, B, sb1, sb0, offsetB, B, sb0, sb1, offsetB );\n\t\t} else {\n\t\t\t// Copy the lower triangular part to the upper triangular part:\n\t\t\tdlacpy( 'lower', nsamples, nsamples, B, sb0, sb1, offsetB, B, sb1, sb0, offsetB );\n\t\t}\n\t}\n\treturn B;\n}\n\n\n// EXPORTS //\n\nexport default dcovmatmtk;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport isOrientation from '@stdlib/blas-base-assert-is-matrix-orientation';\nimport isLayout from '@stdlib/blas-base-assert-is-layout';\nimport isColumnMajor from '@stdlib/ndarray-base-assert-is-column-major-string';\nimport stride2offset from '@stdlib/strided-base-stride2offset';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the covariance matrix for an `M` by `N` double-precision floating-point matrix `A` and assigns the results to a matrix `B` when provided known means and using a one-pass textbook algorithm.\n*\n* ## Notes\n*\n* -   When `orient(A) = 'columns'`,\n*\n*     -   each column in `A` represents a variable and each row in `A` represents an observation.\n*     -   `B` should be an `N` by `N` matrix.\n*     -   the list of known means should be an `N` element vector.\n*\n* -   When `orient(A) = 'rows'`,\n*\n*     -   each row in `A` represents a variable and each column in `A` represents an observation.\n*     -   `B` should be an `M` by `M` matrix.\n*     -   the list of known means should be an `M` element vector.\n*\n* @param {string} order - storage layout of `A` and `B`\n* @param {string} orient - specifies whether variables are stored along columns or along rows\n* @param {string} uplo - specifies whether to overwrite the upper or lower triangular part of matrix `B`\n* @param {NonNegativeInteger} M - number of rows in the matrix `A`\n* @param {NonNegativeInteger} N - number of columns in the matrix `A`\n* @param {number} correction - degrees of freedom adjustment\n* @param {Float64Array} means - vector of known means\n* @param {integer} strideM - stride length of `means`\n* @param {Float64Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float64Array} B - output matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {TypeError} second argument must be a valid orientation\n* @throws {RangeError} fourth argument must be a nonnegative integer\n* @throws {RangeError} fifth argument must be a nonnegative integer\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Define a 2x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'row-major', 'rows', 'full', 2, 3, 1, means, 1, A, 3, B, 2 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*/\nfunction dcovmatmtk( order, orient, uplo, M, N, correction, means, strideM, A, LDA, B, LDB ) {\n\tvar nsamples;\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( !isOrientation( orient ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a valid orientation. Value: `%s`.', orient ) );\n\t}\n\tif ( M < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be a nonnegative integer. Value: `%d`.', M ) );\n\t}\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\tif ( orient === 'rows' ) {\n\t\tnsamples = M;\n\t} else { // orient === 'columns'\n\t\tnsamples = N;\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t}\n\treturn base( orient, uplo, M, N, correction, means, strideM, stride2offset( nsamples, strideM ), A, sa1, sa2, 0, B, sb1, sb2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dcovmatmtk;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport isOrientation from '@stdlib/blas-base-assert-is-matrix-orientation';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the covariance matrix for an `M` by `N` double-precision floating-point matrix `A` and assigns the results to a matrix `B` when provided known means and using a one-pass textbook algorithm and alternative indexing semantics.\n*\n* ## Notes\n*\n* -   When `orient(A) = 'columns'`,\n*\n*     -   each column in `A` represents a variable and each row in `A` represents an observation.\n*     -   `B` should be an `N` by `N` matrix.\n*     -   the list of known means should be an `N` element vector.\n*\n* -   When `orient(A) = 'rows'`,\n*\n*     -   each row in `A` represents a variable and each column in `A` represents an observation.\n*     -   `B` should be an `M` by `M` matrix.\n*     -   the list of known means should be an `M` element vector.\n*\n* @param {string} orient - specifies whether variables are stored along columns or along rows\n* @param {string} uplo - specifies whether to overwrite the upper or lower triangular part of matrix `B`\n* @param {NonNegativeInteger} M - number of rows in the matrix `A`\n* @param {NonNegativeInteger} N - number of columns in the matrix `A`\n* @param {number} correction - degrees of freedom adjustment\n* @param {Float64Array} means - vector of known means\n* @param {integer} strideM - stride length for `means`\n* @param {NonNegativeInteger} offsetM - starting index of `means`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - output matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @throws {TypeError} first argument must be a valid orientation\n* @throws {RangeError} third argument must be a nonnegative integer\n* @throws {RangeError} fourth argument must be a nonnegative integer\n* @returns {Float64Array} `B`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Define a 2x3 matrix in which variables are stored along rows in row-major order:\n* var A = new Float64Array([\n*     1.0, -2.0, 2.0,\n*     2.0, -2.0, 1.0\n* ]);\n*\n* // Define a vector of known means:\n* var means = new Float64Array( [ 1.0/3.0, 1.0/3.0 ] );\n*\n* // Allocate a 2x2 output matrix:\n* var B = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Perform operation:\n* var out = dcovmatmtk( 'rows', 'full', 2, 3, 1, means, 1, 0, A, 3, 1, 0, B, 2, 1, 0 );\n* // returns <Float64Array>[ ~4.3333, ~3.8333, ~3.8333, ~4.3333 ]\n*\n* var bool = ( B === out );\n* // returns true\n*/\nfunction dcovmatmtk( orient, uplo, M, N, correction, means, strideM, offsetM, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB ) {\n\tif ( !isOrientation( orient ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid orientation. Value: `%s`.', orient ) );\n\t}\n\tif ( M < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Third argument must be a nonnegative integer. Value: `%d`.', M ) );\n\t}\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be a nonnegative integer. Value: `%d`.', N ) );\n\t}\n\treturn base( orient, uplo, M, N, correction, means, strideM, offsetM, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB );\n}\n\n\n// EXPORTS //\n\nexport default dcovmatmtk;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport dcovmatmtk from './dcovmatmtk.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dcovmatmtk, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dcovmatmtk;\n"],"names":["dcovmatmtk","orient","uplo","M","N","correction","means","strideM","offsetM","A","strideA1","strideA2","offsetA","B","strideB1","strideB2","offsetB","nsamples","isrmb","full","nobs","sa1","sa0","sb1","sb0","sb","oa","om","ia","ib","im","i0","i1","isRowMajor","dvarmtk","dcovarmtk","dlacpy","order","LDA","LDB","sa2","sb2","isLayout","TypeError","format","isOrientation","RangeError","isColumnMajor","base","stride2offset","setReadOnly","ndarray"],"mappings":"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"}